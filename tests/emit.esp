let n = 0
let t = true
let f = false
let pi = 3.142
let k = -2
let o = -9.8

let a = ||
  let b = 3;
  o = 3.1;
  t = false;
  p(2, 3, false);
  2
end

let b = |c, d| 2; c end

let o : float = 0.0
let r : 0 = 0
let add : int = |a: int, b: int| a + b end

let n :| bool | int = 2

let k = ||
  if a > 2 then
    true
  else
    false
  end;

  fn<T>();

  let x = a - b
end

let lst = vector<int>()
let rng = 2..3
let v = [9, 6, 3]

p.q. = 3
p.q.r. = 4
p.q.r()
p.q.r<bool>()

struct A end

struct B
  c : int,
  d : |a: int| a - c end
end

let p : vector<int> = none

let swap: tuple<int> = |a: int, b: int|
  let tmp = a;
  a = b;
  b = tmp;
  [a, b]
end

(* loops *)

loop a in b [] end
loop p in q.r. [] end

loop i in 0..10
  print(i)
end

loop [a, b] in c
  print(a, b)
end

let f = |n: vector<int>|
  n
end

(* type-related semantics *)

type A = b end

type A<T> = T end

type B<P, Q> = | P | Q end

type A<T, K> = { key: T, value: K } end

type P<Q> = Q.key. end

@extend(S, string) type R<S> = S end

type tree<T> = {
  value: T,
  children: vector<tree<T>>
} end

type R = ?int end                     (* optional alias *)

type S =
  | ?int
  | ?bool
end                                   (* variant of optionals *)

type T = ?| int | bool end            (* optional of variant of types *)

(* pattern matching *)
match a with
| int ->
  print("entering");
  print("int: ", a),
| string -> print("string: ", a),
end
