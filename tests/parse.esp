let add = |a, b| a + b end

let m = |a, b|
  c = a;
  c = k
end

let a = [2, 4, 6]
let a = { p : 1, 2 : k }

let t = true
let f = false

let r = 2..3
let s = i..n

if a > 2 then true else false end

let k = if a > 2 then
  s = r;
  true
else
  false
end

loop i in 2..3
  i * 2;
  2 * i
end

a(2, 3, n + 1)
let p = q(r..s, t..u)

3.14159
(-2.9)
7
(-8)

let v : 0 = 0
let n : int = 1
let p : | bool | float = 0.0

type a = b end
type c =
  | d
  | e
end

type f<g, h> = i end

a()
b<c>()

struct A end

struct B
  b : int,
  _b : bool
end

struct C
  d : float,
  e : || d + d end
end

let (*p*) a = ||
  b = k;
  k = true
end

let p = "string value"
let q = "string delimiters \n a \t b \r c"

let c = 'c'

(* comment *)
(* ignored comment *)
(*
 * ignored
 * multiline comment *)

@abc let n = 0                         (* ident directive + let binding *)
@abc(p = q, true) struct A end         (* call directive + struct expr *)
let k = @abc 2 - 3                     (* assignable, applies to LHS *)
let p = @abc (2 - 3)                   (* assignable, applies to parens *)
@abc @def || 0 end                     (* nested directives, wrap RHS *)

p.q
w(x.y.)
p.q.r()
